{"version":3,"file":"Leaflet.gl.min.js","sources":["../.gobble-watch/04-include/1/Leaflet.gl.js"],"sourcesContent":["// Adds WebGL detection to L.Browser.\n\nL.Browser.gl = false;\n\ntry {\n\tvar canvas = document.createElement('canvas');\n\tvar context = canvas.getContext('webgl');\n\tif (context && typeof context.getParameter == 'function') {\n\t\tL.Browser.gl = 'webgl';\n\t} else {\n\t\tcontext = canvas.getContext('experimental-webgl');\n\t\tif (context && typeof context.getParameter == 'function') {\n\t\t\tL.Browser.gl = 'experimental-webgl';\n\t\t}\n\t}\n} catch(e) {}\n\n\n\nif (L.Browser.gl) {\n\n// L.GlUtil contains shorthands for common WebGL operations\n\nL.GlUtil = {\n\n\tcreateProgram: function(glContext, vertexShaderCode, fragmentShaderCode, attributeNames, uniformNames) {\n\n\t\tvar gl = glContext;\n\n\t\tvar program = gl.createProgram();\n\t\tvar vs = gl.createShader(gl.VERTEX_SHADER);\n\t\tvar fs = gl.createShader(gl.FRAGMENT_SHADER);\n\n\t\tgl.shaderSource(vs, vertexShaderCode);\n\t\tgl.shaderSource(fs, fragmentShaderCode);\n\n\t\tgl.compileShader(vs);\n\t\tgl.compileShader(fs);\n\n\t\tif (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n\t\t\tthrow(new Error(gl.getShaderInfoLog(vs)));\n\t\t}\n\t\tif (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n\t\t\tthrow(new Error(gl.getShaderInfoLog(fs)));\n\t\t}\n\t\tgl.attachShader(program, vs);\n\t\tgl.attachShader(program, fs);\n\t\tgl.linkProgram(program);\n\n\t\tprogram.attributes = {};\n\t\tprogram.uniforms = {};\n\t\tvar i, location, name;\n\t\tif (attributeNames && attributeNames.length) {\n\t\t\tfor (i=0; i<attributeNames.length; i++) {\n\t\t\t\tname = attributeNames[i];\n\t\t\t\tlocation = gl.getAttribLocation(program, name);\n\t\t\t\tif (location === -1) { throw new Error('Attribute ' + name + ' not found in shaders');}\n\t\t\t\tprogram.attributes[name] = location\n\t\t\t}\n\t\t}\n\t\tif (uniformNames && uniformNames.length) {\n\t\t\tfor (i=0; i<uniformNames.length; i++) {\n\t\t\t\tname = uniformNames[i];\n\t\t\t\tlocation = gl.getUniformLocation(program, name);\n\t\t\t\tif (location === -1) { throw new Error('Uniform ' + name + ' not found in shaders');}\n\t\t\t\tprogram.uniforms[name] = location;\n\n\t\t\t}\n\t\t}\n\n\t\treturn program;\n\t},\n\n\n\t// Creates a buffer, inits its data store, and loads initial data into it.\n\t// mode should be:\n\t//   gl.STREAM_DRAW for static data used once\n\t//   gl.STATIC_DRAW for static data (e.g. vector data)\n\t//   gl.DYNAMIC_DRAW for changing dynamic data (e.g. vertices of loaded tiles)\n\tinitBuffer: function(glContext, initialData, mode) {\n\t\tvar gl = glContext;\n\t\tvar buff = gl.createBuffer();\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buff);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, initialData, mode || gl.STATIC_DRAW);\n\t\treturn buff;\n\t},\n\n\n\t// Creates and inits a texture from a **loaded** image (or ready image canvas)\n\tinitTexture: function(glContext, image) {\n\t\tvar gl = glContext;\n\t\tvar tex = gl.createTexture();\n\t\tgl.bindTexture(gl.TEXTURE_2D, tex);\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n// \t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n\t\tgl.generateMipmap(gl.TEXTURE_2D);\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t\treturn tex;\n\t},\n\n\t// Shorthand for bindBuffer + vertexAttribPointer\n\tbindBufferToAttrib: function(glContext, buffer, attrib, size, type) {\n\t\tglContext.bindBuffer(glContext.ARRAY_BUFFER, buffer);\n\n\t\t// attrib index, size, type, normalized (into [-1,1] or [0,1]),\n\t\t// stride (when skiping items), pointer (when start at non-zero)\n\t\tglContext.vertexAttribPointer(attrib, size, type, false, 0, 0);\n\t},\n\n};\n\nL.glUtil = {};\n\n/*\n* Copyright (C) 2008 Apple Inc. All Rights Reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions\n* are met:\n* 1. Redistributions of source code must retain the above copyright\n*    notice, this list of conditions and the following disclaimer.\n* 2. Redistributions in binary form must reproduce the above copyright\n*    notice, this list of conditions and the following disclaimer in the\n*    documentation and/or other materials provided with the distribution.\n*\n* THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n* PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*\n* Ported from MapBox's unitbezier https://github.com/mapbox/unitbezier\n* which is in turn ported from Webkit\n* http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h\n*/\n\nL.GlUtil.UnitBezier = function (p1x, p1y, p2x, p2y) {\n\t// Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).\n\tthis.cx = 3.0 * p1x;\n\tthis.bx = 3.0 * (p2x - p1x) - this.cx;\n\tthis.ax = 1.0 - this.cx - this.bx;\n\n\tthis.cy = 3.0 * p1y;\n\tthis.by = 3.0 * (p2y - p1y) - this.cy;\n\tthis.ay = 1.0 - this.cy - this.by;\n\n\tthis.p1x = p1x;\n\tthis.p1y = p2y;\n\tthis.p2x = p2x;\n\tthis.p2y = p2y;\n};\n\nL.GlUtil.UnitBezier.prototype = {\n\n\tsampleCurveX: function(t) {\n\t\t// `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.\n\t\treturn ((this.ax * t + this.bx) * t + this.cx) * t;\n\t},\n\n\tsampleCurveY: function(t) {\n\t\treturn ((this.ay * t + this.by) * t + this.cy) * t;\n\t},\n\n\tsampleCurveDerivativeX: function(t) {\n\t\treturn (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n\t},\n\n\tsolveCurveX: function(x, epsilon) {\n\t\tif (typeof epsilon === 'undefined') epsilon = 1e-6;\n\n\t\tvar t0, t1, t2, x2, i;\n\n\t\t// First try a few iterations of Newton's method -- normally very fast.\n\t\tfor (t2 = x, i = 0; i < 8; i++) {\n\n\t\t\tx2 = this.sampleCurveX(t2) - x;\n\t\t\tif (Math.abs(x2) < epsilon) return t2;\n\n\t\t\tvar d2 = this.sampleCurveDerivativeX(t2);\n\t\t\tif (Math.abs(d2) < 1e-6) break;\n\n\t\t\tt2 = t2 - x2 / d2;\n\t\t}\n\n\t\t// Fall back to the bisection method for reliability.\n\t\tt0 = 0.0;\n\t\tt1 = 1.0;\n\t\tt2 = x;\n\n\t\tif (t2 < t0) return t0;\n\t\tif (t2 > t1) return t1;\n\n\t\twhile (t0 < t1) {\n\n\t\t\tx2 = this.sampleCurveX(t2);\n\t\t\tif (Math.abs(x2 - x) < epsilon) return t2;\n\n\t\t\tif (x > x2) {\n\t\t\t\tt0 = t2;\n\t\t\t} else {\n\t\t\t\tt1 = t2;\n\t\t\t}\n\n\t\t\tt2 = (t1 - t0) * 0.5 + t0;\n\t\t}\n\n\t\t// Failure.\n\t\treturn t2;\n\t},\n\n\tsolve: function(x, epsilon) {\n\t\treturn this.sampleCurveY(this.solveCurveX(x, epsilon));\n\t}\n};\n\nL.glUtil.unitBezier = function(p1x, p1y, p2x, p2y) {\n\treturn new L.GlUtil.UnitBezier(p1x, p1y, p2x, p2y);\n};\n\n// Adds the most very basic GL animation to L.Map: render the scene every\n//   time there is a 'move' or 'moveend' event.\n// In effect, this makes pan *and* flyTo animations work seamlessly, as\n//   every pan/flyTo frame fires a 'move' event.\n\n\n(function(){\n\n\tvar mapProto = L.extend({}, L.Map.prototype);\n\n\tL.Map.include({\n\t\t_initLayout: function() {\n\t\t\tmapProto._initLayout.call(this);\n\n\t\t\tthis.on('move moveend', function(){\n\t\t\t\tthis._glView.center = this.options.crs.project(this.getCenter());\n\t\t\t\tvar corner = this.options.crs.project(this.containerPointToLatLng(this.getSize()));\n\t\t\t\tthis._glView.halfSize = corner.subtract(this._glView.center);\n\n\t\t\t\tthis.glRenderOnce();\n\t\t\t}, this);\n\t\t}\n\t});\n\n})();\n\n\n// Adds GL zoom animations to L.Map: whenever an animated zoom starts, trigger\n//   the rendering loop, then change the view center and size every frame.\n\n\n(function(){\n\n\tvar mapProto = L.extend({}, L.Map.prototype);\n\n\tL.Map.include({\n\t\t_initLayout: function() {\n\t\t\tmapProto._initLayout.call(this);\n\n\n\t\t\t// There is no need to check for the \"animated\" option: the non-GL\n\t\t\t//   zoom animation code only fires 'zoomanim' when there is actually\n\t\t\t//   a zoom animation underway.\n\t\t\tthis.on('zoomanim', this._onGlZoomAnimationStart, this);\n\t\t\tthis.on('zoomend', this._onGlZoomAnimationEnd, this);\n\t\t},\n\n\t\t// Animation duration, in milliseconds. Should match the duration\n\t\t//   of the non-GL CSS transition\n\t\t_glZoomAnimationDuration: 250,\n\n\t\t// Capture start/end center/halfsize when starting a zoom animation\n\t\t//   (triggered by 'zoomanim')\n\t\t// Could also be added to Map.ZoomAnimation._animateZoom\n\t\t_onGlZoomAnimationStart: function(ev) {\n\n\t\t\tvar startCenter = this.options.crs.project(this.getCenter());\n\t\t\tvar startCorner = this.options.crs.project(this.containerPointToLatLng(this.getSize()));\n\t\t\tvar startHalfSize = startCorner.subtract(startCenter);\n\t\t\t//\n\t\t\tvar endCenter   = this.options.crs.project(this._animateToCenter);\n\t\t\tvar endHalfSize = startHalfSize.divideBy(this.getZoomScale(this._animateToZoom, this._zoom));\n\n\t\t\t// Given the start and end center and halfsizes, infer\n\t\t\t//   which CRS coordinate will stay fixed in the screen\n\t\t\t//   during the animation\n\n\t\t\t// The proportion between the fixed point to the center and to the corner\n\t\t\t//   stays constant between the start and end center-sizes, so\n\t\t\t//   the fixed point f solves: (x-c1) / (c1+s1-x) = (x-c2) / (c2+s2-x)\n\t\t\t// where c1,c2 are start/end center and s1/s1 are start/end half sizes\n\t\t\t// https://www.wolframalpha.com/input/?i=%28x-c1%29+%2F+%28c1%2Bs1-x%29+%3D+%28x-c2%29+%2F+%28c2%2Bs2-x%29+for+x\n\n\t\t\t// x = (c2*s1-c1*s2)/(s1-s2) and s1!=s2 and s1*s2*(c1-c2+s1-s2)!=0\n\n\t\t\tvar c1x = startCenter.x;\n\t\t\tvar c1y = startCenter.y;\n\t\t\tvar c2x = endCenter.x;\n\t\t\tvar c2y = endCenter.y;\n\t\t\tvar s1x = startHalfSize.x;\n\t\t\tvar s1y = startHalfSize.y;\n\t\t\tvar s2x = endHalfSize.x;\n\t\t\tvar s2y = endHalfSize.y;\n\n\t\t\tvar fixedX = (c2x*s1x - c1x*s2x) / (s1x - s2x);\n\t\t\tvar fixedY = (c2y*s1y - c1y*s2y) / (s1y - s2y);\n\n\t\t\tvar fixedCRSCoords = new L.Point(fixedX, fixedY);\n\n\t\t\t// Infer the (current) screen coordinate of the fixed CRS coords\n\n\t\t\tvar fixedContainerCoords = this.latLngToContainerPoint(this.options.crs.unproject( fixedCRSCoords ));\n\n\t\t\t// \t\t\tconsole.log('zoom start', ev);\n\t\t\t// \t\t\tconsole.log('inferred fixed CRS coords:', fixedCRSCoords);\n\t\t\t// \t\t\tconsole.log('inferred fixed Container coords:', fixedContainerCoords);\n\n\t\t\tvar size = this.getSize();\n\t\t\tvar relativeContainerPoint = new L.Point(fixedContainerCoords.x / size.x, fixedContainerCoords.y / size.y).subtract(new L.Point(0.5, 0.5)).multiplyBy(2);\n\n\t\t\t// The animation won't be started instantly. Instead, look for changes on\n\t\t\t//   the zoomproxy pane's CSS for transformations and start\n\t\t\t//   the animation on the first change. So, the initial state of the\n\t\t\t//   zoomproxy CSS transform has to be stored.\n\t\t\tvar transformCSS = this._container.querySelector('.leaflet-proxy.leaflet-zoom-animated').style.transform;\n\n\t\t\tthis._glZoomAnimation = {\n\t\t\t\tstartHalfSize: startHalfSize,\n\t\t\t\tfixedCRSCoords: fixedCRSCoords,\n\t\t\t\trelativeContainerPoint: relativeContainerPoint,\n\t\t\t\tuntil: -1,\t// Animation won't be started until there's a change in the zoom proxy div\n\t\t\t\tbezier: L.glUtil.unitBezier(0, 0, 0.25, 1),\n\t\t\t\ttransformCSS: transformCSS,\n\t\t\t\tscale: this.getZoomScale(this._animateToZoom, this._zoom)\n\t\t\t};\n\n\t\t\tthis.on('glPrepareFrame', this._onGlZoomAnimationFrame);\n\t\t\tthis.glRenderUntil(this._glZoomAnimationDuration);\n\t\t},\n\n\n\t\t// Cancels a zoom animation (triggered on 'zoomend' when the animation is over)\n\t\t// Could also be added to Map.ZoomAnimation._onZoomTransitionEnd\n\t\t_onGlZoomAnimationEnd: function(ev) {\n\t\t\tthis._glZoomAnimation = null;\n\t\t\tthis.off('glPrepareFrame', this._onGlZoomAnimationFrame);\n\t\t},\n\n\t\t// Sets the maps' center and half size, in CRS units,\n\t\t//   taking the zoom animation into account.\n\t\t_onGlZoomAnimationFrame: function() {\n\t\t\tvar center = null;\n\t\t\tvar halfSize = null;\n\n\t\t\tif (!this._glZoomAnimation) { return }\n\n\t\t\tif (this._glZoomAnimation.until === -1) {\n\t\t\t\tvar transformCSS = this._container.querySelector('.leaflet-proxy.leaflet-zoom-animated').style.transform;\n\t\t\t\tif (transformCSS !== this._glZoomAnimation.transformCSS) {\n\t\t\t\t\tthis._glZoomAnimation.until = performance.now() + this._glZoomAnimationDuration;\n// \t\t\t\t\tconsole.log('Zoom animation started until', this._glZoomAnimation.until);\n\t\t\t\t\tthis.glRenderUntil(this._glZoomAnimationDuration);\n\t\t\t\t} else {\n// \t\t\t\t\tconsole.log('Zoom animation delayed');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar anim = this._glZoomAnimation;\n\n\t\t\t// From 0 (animation started) to 1 (animation ended). Clamp at 1,\n\t\t\t// as a couple of frames might run after the zoom animation has ended.\n\t\t\tvar t = Math.min(1 - ((anim.until - performance.now()) / this._glZoomAnimationDuration), 1);\n\n\t\t\t// Map [0,1] to [0,1] in the bezier curve\n\t\t\tvar bezierValue = anim.bezier.solve(t);\n\n\t\t\t// Map [0,1] to [1,anim.scale]\n\t\t\tvar scale = 1 + bezierValue * ( anim.scale - 1);\n\n\t\t\t// Interpolate halfsize, infer center from the fixed point position.\n\t\t\tthis._glView.halfSize = halfSize = anim.startHalfSize.divideBy(scale);\n\n\t\t\tvar offset = new L.Point(\n\t\t\t\thalfSize.x * anim.relativeContainerPoint.x,\n\t\t\t\thalfSize.y * anim.relativeContainerPoint.y  );\n\n\t\t\tthis._glView.center = anim.fixedCRSCoords.subtract( offset );\n\n\n\t\t},\n\n\n\t});\n\n})();\n\n// L.Map is responsible for:\n//  * Creating the destination canvas and WebGL rendering context\n//  * Keeping track of the main WebGL rendering loop, including animations\n//  * Exposing an interface for layers so they can hook up to the map's WebGL\n//      context, programs, and rendering loop.\n\n\n(function(){\n\n\t// Keep a copy of the L.Map prototype before the include() call, so the\n\t//   previous methods can be called before overwriting them.\n\tvar mapProto = L.extend({}, L.Map.prototype);\n\n// \t\tL.Map.addInitHook(function() {\n// \t\t\tthis.on('move moveend', this.glRenderOnce, this);\n// \t\t});\n\n\tL.Map.include({\n\n\t\t_initLayout: function() {\n\n\t\t\tmapProto._initLayout.call(this);\n\n\t\t\tvar size = this.getSize();\n\t\t\tthis._glCanvas = L.DomUtil.create('canvas', 'leaflet-webgl', this._container);\n\t\t\tvar gl = this._gl = this._glCanvas.getContext(L.Browser.gl, {premultipliedAlpha:false});\n\n\n\t\t\tthis._glPrograms = [];\n\t\t\tthis._glLayers = {};\n\t\t\tthis._glView = {};\t// Center and half-size of the current view. Might change every frame.\n\n\t\t\tthis._glResizeCanvas();\n\n\n\t\t\t// When clearing the canvas, set pixels to grey transparent\n\t\t\t// This will make the fade-ins a bit prettier.\n\t\t\tgl.clearColor(0.5, 0.5, 0.5, 0);\n\n\n\t\t\t// Blending is needed for map tiles to be faded in\n\t\t\tgl.enable(gl.BLEND);\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n\n\t\t\t// Depth buffer is needed for rendering things on top of other things with\n\t\t\t//   an explicit order\n\t\t\tgl.enable(gl.DEPTH_TEST);\n\n\t\t},\n\n\n\t\t// Registers a GL program. Classes which can render themselves into\n\t\t//   WebGL are expected to provide their own shader code and register\n\t\t//   the program they use.\n\t\t// Programs are reused between layers. Programs have a short name (e.g.\n\t\t//   'tile', 'marker', 'line', 'circle') - only the first time that\n\t\t//   a program name is registered is taken into account.\n\t\t// The normal workflow for layers is to register a program, then attach\n\t\t//   themselves to that program; but there should be cases where a layer\n\t\t//   might not attach itself to a program until some condition is met; or\n\t\t//   it might detach and re-attach itself - that's why register and attach\n\t\t//   are different functions.\n\t\tregisterGlProgram: function(programName, priority, vShader, fShader, attribs, uniforms) {\n\t\t\tif (programName in this._glLayers) { return; }\n\n\t\t\tthis._glLayers[programName] = [];\n\n\t\t\tvar gl = this._gl;\n\t\t\tif (!gl) {\n\t\t\t\tthrow Error('A layer tried to register a WebGL program before the map initialized its layout and WebGL context.');\n\t\t\t}\n\n\t\t\t/// TODO: Find a way to switch between crs2clipspace shader functions, to switch\n\t\t\t///   between perspective models.\n\t\t\tvar crs2clipspace = 'uniform vec2 uCenter,uHalfViewportSize;vec4 crs2clipspace(vec4 a){return vec4((a.x-uCenter.x)/uHalfViewportSize.x,(-a.y+uCenter.y)/uHalfViewportSize.y,a[2],a[3]);}' + '\\n' ;\n\n\t\t\tvar program = L.GlUtil.createProgram(gl,\n\t\t\t\tcrs2clipspace +  vShader,\t// Vertex shader\n\t\t\t\tfShader,\t// Fragment shader\n\t\t\t\tattribs,\t// Attributes\n\t\t\t\t['uCenter', 'uHalfViewportSize'].concat(uniforms)\t// crs2clipspace uniforms + program uniforms\n\t\t\t);\n\n\t\t\tprogram.priority = priority;\n\t\t\tprogram.name = programName;\n\n\t\t\t// We're assuming all attributes will be in arrays\n\t\t\tfor (var attrib in program.attributes) {\n\t\t\t\tgl.enableVertexAttribArray(program.attributes[attrib]);\n\t\t\t}\n\n\t\t\tthis._glPrograms.push(program);\n\t\t\tthis._glPrograms.sort(function(a, b){return a.priority - b.priority});\n\n\t\t},\n\n\n\t\t// GL layers will want to tell the map which GL program they want\n\t\t//   to use when rendering (akin to the map panes in non-GL).\n\t\tattachLayerToGlProgram: function(layer, programName) {\n\t\t\tif (!(programName in this._glLayers)) {\n\t\t\t\tthrow new Error('Layer tried to attach to a non-existing GL program');\n\t\t\t}\n\t\t\tthis._glLayers[programName].push(layer);\n\t\t\treturn this;\n\t\t},\n\n\t\t// Reverse of attachLayerToGlProgram\n\t\tdetachLayerFromGlProgram: function(layer, programName) {\n\t\t\tif (!(programName in this._glLayers)) {\n\t\t\t\tthrow new Error('Layer tried to detach from a non-existing GL program');\n\t\t\t}\n\t\t\tthis._glLayers[programName].splice(\n\t\t\t\tthis._glLayers[programName].indexOf(layer), 1);\n\t\t\treturn this;\n\t\t},\n\n\t\t// Exposes this._gl\n\t\tgetGlContext: function() {\n\t\t\treturn this._gl;\n\t\t},\n\n\n\t\t// Start the GL rendering loop.\n\t\t// Receives a number of milliseconds - how long to keep requesting\n\t\t//   animation frames and re-rendering the GL canvas.\n\t\t// This can be zero milliseconds, which means \"render just once\"\n\t\tglRenderUntil: function(milliseconds) {\n\t\t\tif (!this._glEndTime) {\n\t\t\t\tthis.fire('glRenderStart', {now: performance.now()});\n\t\t\t\tthis._glEndTime = performance.now() + milliseconds;\n\t\t\t\tL.Util.requestAnimFrame(this._glRender, this);\n\t\t\t} else {\n\t\t\t\tthis._glEndTime = Math.max(\n\t\t\t\t\tperformance.now() + milliseconds,\n\t\t\t\t\tthis._glEndTime\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\n\t\t// Ask for the scene to be rendered once, but only if a GL render loop\n\t\t//   is not already active.\n\t\tglRenderOnce: function() {\n\t\t\tif (!this._glEndTime) {\n\t\t\t\tthis._glEndTime = 1;\n\t\t\t\tL.Util.requestAnimFrame(this._glRender, this);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\n\t\t// Renders one frame by setting the viewport uniforms and letting layers\n\t\t//   render themselves.\n\t\t// Also controls the main render loop, requesting the next animFrame or stopping\n\t\t//   the loop if no more rendering is needed.\n\t\t_glRender: function() {\n\t\t\tvar now = performance.now();\n\n\t\t\tif (this._glEndTime && this._glEndTime > now) {\n\t\t\t\tL.Util.requestAnimFrame(this._glRender, this);\n\t\t\t} else {\n\t\t\t\tthis._glEndTime = null;\n\t\t\t\tthis.fire('glRenderEnd', {now: performance.now()});\n\t\t\t}\n\n\t\t\tvar gl = this._gl;\n\n\t\t\t// Render the scene in several phases, switching shader programs\n\t\t\t//   once per phase:\n\t\t\t// - Tile layers\n\t\t\t// - Marker shadows\n\t\t\t// - Vector data\n\t\t\t// - Markers\n\t\t\t// This mimics the z-index of the panes in 2D mode.\n\t\t\t// A phase will be rendered only when it has at least one layer to\n\t\t\t//   render. Otherwise it's a waste of resources to enable the\n\t\t\t//   shaders for that phase.\n\n\t\t\tgl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n\n\t\t\t// Fetch center, half size in CRS units\n\t\t\t// These bits of data are set on a per-frame basis by the animations code,\n\t\t\t//   by listening to the 'glPrepareFrame' event.\n\t\t\tthis.fire('glPrepareFrame');\n\t\t\tvar view = this._glView;\n\n\t\t\tvar i;\n\t\t\t// The programs array comes pre-sorted from registerGlProgram().\n\t\t\tfor (var programPriority in this._glPrograms) {\n\t\t\t\tvar program = this._glPrograms[programPriority];\n\t\t\t\tvar programName = program.name;\n\n\t\t\t\tif (this._glLayers[programName].length) {\n\t\t\t\t\tgl.useProgram(program);\n\n\t\t\t\t\t// Push crs2clipspace uniforms\n\t\t\t\t\tgl.uniform2f(program.uniforms.uCenter, view.center.x, view.center.y);\n\t\t\t\t\tgl.uniform2f(program.uniforms.uHalfViewportSize, view.halfSize.x, view.halfSize.y);\n\n\t\t\t\t\t// Let each layer render itself using the program they need.\n\t\t\t\t\t// The layer will rebind vertex attrib arrays and uniforms as needed\n\t\t\t\t\tfor (i in this._glLayers.tile) {\n\t\t\t\t\t\tthis._glLayers.tile[i].glRender(program);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// A bit of accounting will come in handy for debugging.\n\t\t\tvar end = performance.now();\n\t\t\tvar frameTime = end - now;\n\t\t\tvar fps = 1000 / (end - this._glLastFrameTimestamp);\n\t\t\tthis.fire('glRenderFrame', {now: end, frameTime: frameTime, fps: fps});\n\t\t\tthis._glLastFrameTimestamp = end;\n\t\t},\n\n\n\t\tinvalidateSize: function(options) {\n\t\t\tmapProto.invalidateSize.call(this, options);\n\t\t\tthis._glResizeCanvas();\n\t\t\tthis.glRenderOnce();\n\t\t},\n\n\t\t_glResizeCanvas: function() {\n\t\t\tvar size = this.getSize();\n\t\t\tthis._glCanvas.style.width  = size.x + 'px';\n\t\t\tthis._glCanvas.style.height = size.y + 'px';\n\t\t\tthis._glCanvas.width  = size.x;\n\t\t\tthis._glCanvas.height = size.y;\n\t\t\tthis._gl.viewportWidth  = this._glCanvas.width;\n\t\t\tthis._gl.viewportHeight = this._glCanvas.height;\n\t\t}\n\n\n\t});\n\n\n})();\n\n// L.TileLayer modifies the behaviour of all tilelayers to use WebGL\n//   to render themselves.\n\n(function(){\n\n\tvar tileLayerProto = L.extend({}, L.TileLayer.prototype);\n\n\tL.TileLayer.addInitHook(function(){\n\t\t// Cross-origin stuff needed for images to be loaded into textures.\n\t\t// If the tileserver does not allow CORS, tiles cannot be loaded into\n\t\t//   a canvas or a WebGL texture.\n\t\tthis.options.crossOrigin = true;\n\t});\n\n\n\tL.TileLayer.include({\n\n\t\tonAdd: function(map) {\n\t\t\ttileLayerProto.onAdd.call(this, map);\n\n\t\t\t// Tell the map we'll be using a GL program to render ourselves, instead of\n\t\t\t//   a map pane.\n\t\t\t// Programs are reused between layers which share a program with the same\n\t\t\t//   name.\n\t\t\tmap.registerGlProgram('tile', 1,\n\t\t\t\t'precision mediump float;attribute vec3 aCRSCoords;attribute vec2 aTextureCoords;varying vec2 a;attribute float aAge;varying float b;uniform float uTileZoom;void main(){gl_Position=crs2clipspace(vec4(aCRSCoords.x,aCRSCoords.y,0,1));gl_Position.z+=abs(aCRSCoords.z-uTileZoom)*1e-5;a=aTextureCoords;b=aAge;}',\t// Vertex shader\n\t\t\t\t'precision mediump float;varying vec2 a;varying float b;uniform sampler2D uTexture;uniform float uNow;void main(){lowp vec4 c=texture2D(uTexture,vec2(a.s,a.t));c.a*=clamp((uNow-b)/2e2,0.,1.);gl_FragColor=c;}',\t// Fragment (pixel) shader\n\t\t\t\t['aCRSCoords', 'aTextureCoords', 'aAge'],\t// Attributes\n\t\t\t\t['uNow', 'uTexture', 'uTileZoom']\t// Uniforms\n\t\t\t);\n\t\t\tmap.attachLayerToGlProgram(this, 'tile');\n\t\t},\n\n\t\tonRemove: function(map) {\n\t\t\ttileLayerProto.onRemove.call(this, map);\n\n\t\t\tmap.detachLayerFromGlProgram(this, 'tile');\n\t\t},\n\n\t\t// Prevent creating an element and adding it to a map pane by doing nothing here.\n\t\t_initContainer: function() {},\n\n\n\t\t// When the underlying image is done, create triangles\n\t\t//   and add texture.\n\t\t_tileReady: function(tileCoords, err, tile) {\n\t\t\tif (!this._map) { return; }\n\n\t\t\tif (err) {\n\t\t\t\tthis.fire('tileerror', {\n\t\t\t\t\terror: err,\n\t\t\t\t\ttile: tile,\n\t\t\t\t\tcoords: coords\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar key = this._tileCoordsToKey(tileCoords);\n\n\t\t\ttile = this._tiles[key];\n\t\t\tif (!tile) { return; }\n\n\t\t\t// Pack data from this tile into a low-level array, which will\n\t\t\t//   later form an interleaved array buffer.\n\t\t\t// A tile is two triangles in a triangle strip, defined by 4 vertices.\n\t\t\t// Each vertex has 3 coordinates, two texture coordinates, one age.\n\t\t\ttile.glData = new Float32Array(24);\n\t\t\ttile.age = performance.now();\n\n\t\t\tvar crsCoords = this._tileCoordsToProjectedBounds(tileCoords);\n\t\t\tvar tileZoom = tile.coords.z;\n\n\t\t\ttile.glData.set([\n\t\t\t\tcrsCoords.min.x, crsCoords.min.y, tileZoom,\n\t\t\t\t0, 1,\n\t\t\t\ttile.age,\n\n\t\t\t\tcrsCoords.max.x, crsCoords.min.y, tileZoom,\n\t\t\t\t1, 1,\n\t\t\t\ttile.age,\n\n\t\t\t\tcrsCoords.min.x, crsCoords.max.y, tileZoom,\n\t\t\t\t0, 0,\n\t\t\t\ttile.age,\n\n\t\t\t\tcrsCoords.max.x, crsCoords.max.y, tileZoom,\n\t\t\t\t1, 0,\n\t\t\t\ttile.age\n\t\t\t]);\n\n\t\t\ttile.texture = L.GlUtil.initTexture(this._map.getGlContext(), tile.el);\n\n\t\t\tthis.fire('tileload', {\n\t\t\t\ttile: tile.el,\n\t\t\t\tcoords: tileCoords\n\t\t\t});\n\n\t\t\tif (this._noTilesToLoad()) {\n\t\t\t\tthis._loading = false;\n\t\t\t\tthis.fire('load');\n\t\t\t}\n\n\t\t\t// The fade-in animation will run for 500 milliseconds, as coded in\n\t\t\t//   the fragment shader.\n\t\t\tthis._map.glRenderUntil(500);\n\t\t},\n\n\n\t\t// A light version of _tileCoordsToBounds, which doesn't unproject\n\t\t//   the map's CRS to LatLng.\n\t\t_tileCoordsToProjectedBounds: function(coords) {\n\n\t\t\tvar map = this._map,\n\t\t\t\tcrs = map.options.crs,\n\t\t\t\ttransformation = crs.transformation,\n\t\t\t\ttileSize = this._getTileSize(),\n\t\t\t\tscale = crs.scale(coords.z),\n\t\t\t\tnwPoint = coords.multiplyBy(tileSize),\n\t\t\t\tsePoint = nwPoint.add([tileSize, tileSize]);\n\n\t\t\tnwPoint = transformation.untransform(nwPoint, scale);\n\t\t\tsePoint = transformation.untransform(sePoint, scale);\n\n\t\t\treturn new L.Bounds(nwPoint, sePoint);\n\t\t},\n\n\t\t_removeTile: function (key) {\n\t\t\tvar tile = this._tiles[key];\n\t\t\tif (!tile) { return; }\n\n// \t\t\tconsole.log('remove ', key, performance.now());\n\t\t\twindow.setTimeout(function(){\n\t\t\t\t// Wait a bit until other tiles have faded in\n\t\t\t\tthis._map.getGlContext().deleteTexture(tile.texture);\n\t\t\t\tdelete this._tiles[key];\n\t\t\t}.bind(this), 500);\n\n\t\t\tthis.fire('tileunload', {\n\t\t\t\ttile: tile.el,\n\t\t\t\tcoords: this._keyToTileCoords(key)\n\t\t\t});\n\t\t},\n\n\t\t_invalidateGlVertexBuffer: function(){\n\t\t\tthis.map.getGlContext().destroyBuffer(this._glVertexBuffer);\n\t\t\tthis._glVertexBuffer = null;\n\t\t},\n\n\n\t\t// Cache buffers with data needed to render the tiles.\n\t\t// This includes an interleaved vertices&attributes array,\n\t\t//   and the texture array.\n\t\t// This is what OpenLayers3 calls \"batches\" or \"replays\".\n\t\t_getGlBuffers: function(){\n\n\t\t\tif (this._glBuffers) {\n\t\t\t\treturn this._glBuffers;\n\t\t\t}\n\n\t\t\tvar length = Object.keys(this._tiles).length;\n\t\t\tvar gl = this._map.getGlContext();\n\n\t\t\t// Each tile is represented by 2 triangles in a triangle strip\n\t\t\t//   = 6 coordinate pairs = 12 floats.\n\t\t\tvar bytesPerTile = 24;\n\t\t\tvar vertices = new Float32Array(length * bytesPerTile);\n\t\t\tvar i = 0;\t// Count of tiles actually loaded\n\t\t\tvar textures = [];\n\n\t\t\tfor (var key in this._tiles) {\n\t\t\t\tvar tile = this._tiles[key];\n\t\t\t\tif (tile.age) {\n\t\t\t\t\tvertices.set(tile.glData, i * bytesPerTile);\n\t\t\t\t\ttextures[i] = tile.texture;\n\t\t\t\t\ti ++;\t// Tile count\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tvertices: L.GlUtil.initBuffer(gl, vertices, gl.DYNAMIC_DRAW),\n\t\t\t\ttextures: textures,\n\t\t\t\tlength: i\t// tile count\n\t\t\t};\n\t\t},\n\n\n\n\t\t// This is run by the map whenever the layer must re-render itself.\n\t\t// glRender() must re-attach vertices&attributes buffers,\n\t\t//    layer-specific uniforms, and do the low-level calls to render\n\t\t//    whatever geometries are needed.\n\t\tglRender: function(program, programName) {\n\t\t\tvar gl = this._map.getGlContext();\n\t\t\tvar buffers = this._getGlBuffers();\n\n\t\t\tgl.uniform1f(program.uniforms.uTileZoom, this._tileZoom);\n\t\t\tgl.uniform1f(program.uniforms.uNow, performance.now());\n\n\t\t\t// Bind the interleaved vertices&attributes buffer to three different\n\t\t\t//   attributes.\n\t\t\t// Each tile is 12 floats = 24 bytes:\n\t\t\t//   Vertices start at 0\n\t\t\t//   Texture coords start after 3 floats = 12 bytes\n\t\t\t//   Tile age starts after 5 floats = 20 bytes\n\t\t\tvar attribs = program.attributes;\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertices);\n\t\t\tgl.vertexAttribPointer(attribs.aCRSCoords,     3, gl.FLOAT, false, 24, 0);\n\t\t\tgl.vertexAttribPointer(attribs.aTextureCoords, 2, gl.FLOAT, false, 24, 12);\n\t\t\tgl.vertexAttribPointer(attribs.aAge,           1, gl.FLOAT, false, 24, 20);\n\n\t\t\t// Render tiles one by one. Bit inefficient, but simpler at\n\t\t\t//   this stage in development.\n\t\t\tfor (var i=0; i< buffers.length; i++) {\n\n\t\t\t\tgl.activeTexture(gl.TEXTURE0);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, buffers.textures[i]);\n\t\t\t\tgl.uniform1i(program.uniforms.uTexture, 0);\n\n\t\t\t\t// A tile is two triangles = 4 vertices\n\t\t\t\tgl.drawArrays(gl.TRIANGLE_STRIP, i * 4, 4);\n// \t\t\t\tgl.drawArrays(gl.LINE_LOOP, j, 4);\n\t\t\t}\n\t\t}\n\n\t});\n\n})();\n\n}\n"],"names":["L","Browser","gl","canvas","document","createElement","context","getContext","getParameter","e","GlUtil","createProgram","glContext","vertexShaderCode","fragmentShaderCode","attributeNames","uniformNames","program","vs","createShader","VERTEX_SHADER","fs","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","Error","getShaderInfoLog","attachShader","linkProgram","attributes","uniforms","i","location","name","length","getAttribLocation","getUniformLocation","initBuffer","initialData","mode","buff","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","initTexture","image","tex","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","generateMipmap","bindBufferToAttrib","buffer","attrib","size","type","vertexAttribPointer","glUtil","UnitBezier","p1x","p1y","p2x","p2y","this","cx","bx","ax","cy","by","ay","prototype","sampleCurveX","t","sampleCurveY","sampleCurveDerivativeX","solveCurveX","x","epsilon","t0","t1","t2","x2","Math","abs","d2","solve","unitBezier","mapProto","extend","Map","include","_initLayout","call","on","_glView","center","options","crs","project","getCenter","corner","containerPointToLatLng","getSize","halfSize","subtract","glRenderOnce","_onGlZoomAnimationStart","_onGlZoomAnimationEnd","_glZoomAnimationDuration","ev","startCenter","startCorner","startHalfSize","endCenter","_animateToCenter","endHalfSize","divideBy","getZoomScale","_animateToZoom","_zoom","c1x","c1y","y","c2x","c2y","s1x","s1y","s2x","s2y","fixedX","fixedY","fixedCRSCoords","Point","fixedContainerCoords","latLngToContainerPoint","unproject","relativeContainerPoint","multiplyBy","transformCSS","_container","querySelector","style","transform","_glZoomAnimation","until","bezier","scale","_onGlZoomAnimationFrame","glRenderUntil","off","performance","now","anim","min","bezierValue","offset","_glCanvas","DomUtil","create","_gl","premultipliedAlpha","_glPrograms","_glLayers","_glResizeCanvas","clearColor","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","DEPTH_TEST","registerGlProgram","programName","priority","vShader","fShader","attribs","crs2clipspace","concat","enableVertexAttribArray","push","sort","a","b","attachLayerToGlProgram","layer","detachLayerFromGlProgram","splice","indexOf","getGlContext","milliseconds","_glEndTime","max","fire","Util","requestAnimFrame","_glRender","viewport","drawingBufferWidth","drawingBufferHeight","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","view","programPriority","useProgram","uniform2f","uCenter","uHalfViewportSize","tile","glRender","end","frameTime","fps","_glLastFrameTimestamp","invalidateSize","width","height","viewportWidth","viewportHeight","tileLayerProto","TileLayer","addInitHook","crossOrigin","onAdd","map","onRemove","_initContainer","_tileReady","tileCoords","err","_map","error","coords","key","_tileCoordsToKey","_tiles","glData","Float32Array","age","crsCoords","_tileCoordsToProjectedBounds","tileZoom","z","set","texture","el","_noTilesToLoad","_loading","transformation","tileSize","_getTileSize","nwPoint","sePoint","add","untransform","Bounds","_removeTile","window","setTimeout","deleteTexture","bind","_keyToTileCoords","_invalidateGlVertexBuffer","destroyBuffer","_glVertexBuffer","_getGlBuffers","_glBuffers","Object","keys","bytesPerTile","vertices","textures","DYNAMIC_DRAW","buffers","uniform1f","uTileZoom","_tileZoom","uNow","aCRSCoords","FLOAT","aTextureCoords","aAge","activeTexture","TEXTURE0","uniform1i","uTexture","drawArrays","TRIANGLE_STRIP"],"mappings":"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"}